\documentclass{article}
\usepackage[left=2cm,right=2cm,top=3cm,bottom=3cm,letterpaper]{geometry}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}

\usepackage{verbatim, array}
\usepackage{hyperref}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{graphicx}

\renewcommand{\labelenumii}{\theenumii)}
\newcommand{\gradeone}{(\textbf{1pt}) }
\newcommand{\grade}[1]{(\textbf{#1pts}) }
\newcommand{\header}[1]{\begin{center}\textbf{#1}\end{center}\vskip10pt}
\newcommand{\jimage}[2]{\includegraphics[width=#1\textwidth]{#2}\vskip10pt}
\newcommand{\jcimage}[2]{\begin{center}\includegraphics[width=#1\textwidth]{#2}\end{center}\vskip10pt}

\author{Profesora: Karla Ramírez Pulido\\
  Ayudante teoría: Joshua Emmanuel Mendoza Mendieta\\
  Ayudante laboratorio: Héctor Enrique Gómez Morales}
\title{Practica 3 - Data Types Parte 2 de 2}
\date{Fecha de inicio: 20 de febrero de 2015\\
  \textbf{Fecha de entrega: 6 de marzo de 2015}}
\begin{document}
\maketitle
\section{Instrucciones}
En esta práctica se tienen doce ejercicios, los primeros once son
obligatorios siendo solamente el ultimo opcional con valor de un
punto extra. Por lo tanto la calificación máxima que se puede obtener en
esta práctica es 11.

Esta practica se puede entregar en equipos de a lo máximo dos
personas, pero se recomienda que esta practica la hagan de forma
individual.

Esta práctica debe ser implementada con la variante plai, es decir
su archivo rkt debe tener como primer linea lo siguiente:
\texttt{\#lang plai}. Pueden utilizar sólo la paquetería básica de
\texttt{racket/base}, las funciones que se implementaron en la
practica 1 y funciones auxiliares que ustedes definan.

Todos los ejercicios requieren contar con pruebas mediante el uso de
la función \texttt{test}:
\begin{verbatim}
(test <result-expr> <expected-expr>)
\end{verbatim}

En donde \textit{result-expr} es la expresión que se evalúa a cierto
valor que es comparado con \textit{expected-expr} que es otra
expresión que evalúa al valor esperado. Si las dos expresiones evalúan
a lo mismo la prueba imprime el éxito de la prueba, en caso contrario
indicar un error.

\begin{verbatim}
> (test (+ 1 2) 3)
(good (+ 1 2) 3 3 "at line 34")

> (test (+ 1 2) 4)
(bad (+ 1 2) 3 4 "at line 36")
\end{verbatim}

Cada ejercicio debe contar al menos con cinco pruebas.

\section{Ejercicios}
\textbf{Sección I. Tipos de datos recursivos y no recursivos} Define
los siguientes tipos de datos que se te piden.

\begin{itemize}
\item $\textbf{Array}$ - Definir un tipo de dato \texttt{Array}
  que tenga un constructor de tipo \texttt{MArray}. El entero sirve
  para definir el tamaño del arreglo., \textit{i.e.}
\begin{verbatim}
> (MArray 4 '(1 2 3))
(Marray 4 '(1 2 3))
\end{verbatim}
\end{itemize}

\textbf{Sección II. Árboles Binarios}
Para las siguientes funciones, utiliza el tipo de dato \verb;BTree;
definido en \verb;practica3-base.rkt;:
\begin{verbatim}
(define-type BTree
  [EmptyBT]
  [BNode (c procedure?)
         (l BTree?)
         (e any?)
         (r BTree?)])
\end{verbatim}

Donde el primer parámetro del constructor de tipo \verb;BNode; es una función de comparación que recibe dos argumentos y regresa un booleano, indicando si el primer argumento es menor que el segundo. Para un árbol de números, la función de comparación sería \verb;<;, para strings sería \verb;string<?;. \\
    
En esta práctica utilizaremos abreviaciones para los constructores de tipos:

\begin{enumerate}
\item \verb;ebt; es lo mismo que \verb;(EmptyBT);
\item \verb;(bnn ebt 1 ebt); es lo mismo que \verb;(BNode < (EmptyBT) 1 (EmptyBT));
\item \verb;(bns ebt ``hello'' ebt); es lo mismo que \verb;(BNode string<? (EmptyBT) ``hello'' (EmptyBT));
\end{enumerate}

Por último, cuentas con la función \verb;printAB; que recibe un árbol de tipo BTree y regresa su representación gráfica, para que puedas depurar tu código: \\

\jimage{0.9}{imgs/printab1.png}

\newpage
\begin{itemize}
\item \texttt{nniAB} - Dado un árbol de tipo ArbolB, determinar el número de nodos internos que tiene.
\begin{verbatim}
> (nniAB (HVaciaB))
0
> (nniAB (NodoB < (NodoB < (HVaciaB) 3 (HVaciaB)) 1 (NodoB < (HVaciaB) 2 (HVaciaB))))
1
\end{verbatim}

\item \texttt{nhAB} - Dado un árbol de tipo ArbolB, determinar el número de hojas no vacías.
\begin{verbatim}
> (nhAB (HVaciaB))
0
> (nhAB (NodoB < (NodoB < (HVaciaB) 3 (HVaciaB)) 1 (NodoB < (HVaciaB) 2 (HVaciaB))))
2
\end{verbatim}

\item \texttt{nnAB} - Dado un árbol de tipo ArbolB, determinar el número de nodos que tiene. Las hojas vacías no cuentan.
\begin{verbatim}
> (nnAB (HVaciaB))
0
> (nnAB (NodoB < (NodoB < (HVaciaB) 3 (HVaciaB)) 1 (NodoB < (HVaciaB) 2 (HVaciaB))))
3
\end{verbatim}

\item \texttt{mapAB} - Dado una función de aridad 1 y un árbol de tipo ArbolB, aplicar la función sobre todos los valores de los nodos del árbol (las funciones de aridad 1 sólo regresas números).
\begin{verbatim}
> (mapAB add1 (HVaciaB))
(HVaciaB)
> (mapAB add1 (NodoB < (HVaciaB) 1 (NodoB < (HVaciaB) 2 (HVaciaB))))
(NodoB < (HVaciaB) 2 (NodoB < (HVaciaB) 3 (HVaciaB)))
> (mapAB (lambda (x) (* x x)) (NodoB < (HVaciaB) 3 (NodoB < (HVaciaB) 2 (HVaciaB))))
(NodoB < (HVaciaB) 9 (NodoB < (HVaciaB) 4 (HVaciaB)))
\end{verbatim}

\newpage
\item Ahora, sea \verb;arbol-base;\dots
\begin{verbatim}
(define arbol-base (nds (nds (nds vc "A" vc) "B" (nds (nds vc "C" vc) "D" (nds vc "E" vc)))
                   "F"
                   (nds vc "G" (nds (nds vc "H" vc) "I" vc))))
\end{verbatim}
\begin{enumerate}
\item  \textbf{preorderAB} - Dado un arbol de tipo ArbolB, regresar una lista de sus elementos recorridos en preorden.
\begin{verbatim}
> (preorderAB arbol-base)
'("F" "B" "A" "D" "C" "E" "G" "I" "H")
\end{verbatim}

\item  \textbf{inorderAB}  - Dado un arbol de tipo ArbolB, regresar una lista de sus elementos recorridos en inorden.
\begin{verbatim}
> (inorderAB arbol-base)
'("A" "B" "C" "D" "E" "F" "G" "H" "I")
\end{verbatim}

\item \grade {} \textbf{posorderAB} - Dado un arbol de tipo ArbolB, regresar una lista de sus elementos recorridos en post-orden.
\begin{verbatim}
> (posorderAB arbol-base)
'("A" "C" "E" "D" "B" "H" "I" "G" "F")
\end{verbatim}
   
\end{enumerate}

\jimage{0.8}{imgs/orders.png}
\end{itemize}

\textbf{Punto extra:} \texttt{in-figure-3D?} - Dados los siguientes tipos de datos:
\begin{itemize}
\item{ \texttt{3D-Point} que define un punto en 3D.}
\item{\texttt{Figure3D} que define una figura en 3D que tenga al menos tres variantes (por ejemplo: Sphere, Cube)}.
\end{itemize}
Entonces se debe implementar \texttt{in-figure-3D?} que tome una figura \texttt{fig} del tipo \texttt{Figure3D} y una posición \texttt{p} del tipo \texttt{3D-Point} entonces regresa \#t si \texttt{p} esta dentro de \texttt{fig} y \#f en caso contrario
\end{document}
