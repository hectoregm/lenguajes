\documentclass{article}
\usepackage[left=2cm,right=2cm,top=3cm,bottom=3cm,letterpaper]{geometry}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}

\usepackage{verbatim, array}
\usepackage{hyperref}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{graphicx}
\usepackage[T1]{fontenc}

\newcommand{\gradeone}{(\textbf{1pt}) }
\newcommand{\grade}[1]{(\textbf{#1pts}) }
\newcommand{\jimage}[2]{\includegraphics[width=#1\textwidth]{#2}\vskip10pt}
\newcommand{\jcimage}[2]{\begin{center}\includegraphics[width=#1\textwidth]{#2}\end{center}\vskip10pt}

\author{Profesora: Karla Ramírez Pulido \and
  Ayudante: Héctor Enrique Gómez Morales}
\title{Practica Reposición - Recolección de Basura}
\date{Fecha de inicio: 11 de diciembre de 2015\\
  \textbf{Fecha de entrega: 4 de enero de 2016}}
\begin{document}
\maketitle
\section{Instrucciones}
Implementarás un recolector de basura, a escoger \textbf{marcado & barrido} o \textbf{detente & copia}.
Como vimos, la recolección de basura involucra comenzar desde el \textit{conjunto raíz} de referencias,
que residen en las variables locales y los \textit{stack frames}, y buscar los valores alcanzables en el heap.
Para esta práctica incluimos código de soporte para que tu recolector tenga acceso al conjunto raiz de un
programa en ejecución, de tal forma que solo tendrás que concentrarte en la implementación de los algoritmos de
recolección de basura.

El codigo de soporte esta incluido en el archivo zip que contiene este documento, también esta disponible
en: \textbf{http://valhalla.fciencias.unam.mx/lenguajes/gc-support.tgz}

\section*{GC Collector Racket}
En tu recolector deberás utilizar el lenguaje \textbf{#lang plai/collector} al iniico del archivo
para tener a tu disposicion los siguientes procedimientos:

\begin{itemize}
\item \verb;(get-root-set id ...);: produce una lista que representa el conjunto actual de raices, incluyendo
  una entrada por cada \verb;id; adicional.
\item \verb;(root-name root);: dada una raíz, regresa su nombre como un símbolo. Si la raíz corresponde a una
  variable del programa, el nombre sera el mismo. En otro caso, sera tmpXXX. Este procedimiento te ayudara a
  depurar tu recolector.
\item \verb;(read-root root);: dada una raíz, regresa la localidad a la que hace referencia en el momento
  actual.
\item \verb;(set-root! root new-loc);: dada una raíz y una localidad, actualiza la raíz para hacer referencia
  a una nueva localidad.
\item \verb;(procedure-roots proc);: dado un closure almacenado en el heap, regresa el conjunto raíz que es
  alcanzable desde el ambiente del closure, si el \verb;proc; no es alcanzable, regresa la lista vacía.
\end{itemize}

\section*{collector.ss}
Incluimos un \textbf{collector} trivial que no realiza recolección de basura (i.e., cuando se acaba la memoria
simplemente se detiene y marca un error). Tendrias que realizar tu propio modulo -para el algoritmo de recoleccion
que escogiste- que implementen la misma interfaz. La interfaz es como sigue:

\begin{itemize}
\item \verb;gc:alloc-flat : num U sym U bool U empty -> loc;: Este procedimiento debería almacenar un valor
  plano de Racket (number, symbol, boolean, empty list) en el heap, regresando su localidad (un numero). El valor
  debería ocupar una celda en el heap, aunque puedes usar espacio adicional para almacenar una etiqueta, etc.
  Puedes pre-almacenar constantes comunes (e.g., empty list) . De ser necesario, este procedimiento debe
  realizar recolección de basura, si después de esto, el espacio sigue siendo insuficiente, se debería lanzar
  un error.
\end{itemize}

\end{document}
